github.com/simpleego/javastudy
https://github.com/simpleego/JavaStudy/blob/main/website.md
https://www.online-java.com/ 온라인 자바 설치없이 자바가능
https://wikidocs.net/205
https://www.jetbrains.com/idea/download/?section=windows

자판기 site:github.com 로 검색엔진에 검색을 하면 해당 사이트에서만 찾음("자판기" 에대한것을 github.com에서만 찾음)

깃허브 구글 로그인


뉴렉처: 추천 유튜브 자바 상세설명

자바(java), 명령프롬프트 (cmd)ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

kor(변수)=90(값) 

mkdir : 폴더 생성 

copy : 파일복사

del : 파일삭제

rm : 폴더 삭제

tree : 파일을 나무뿌리 모양으로 보여줌

ctrl + c : tree 생성을 중지시킴 (너무 많을 경우 사용)

dir : 파일 목록을 보여주는 'Directory'의 약자.

cd : Change Directory (디렉터리 변경) 현재 작업 중인 디렉터리(폴더)의 위치를 이동할 때 사용하는 명령어
cd 폴더변경
 -예시 cd c:\users>cd jdk = c:\users\jdk

cd .. : 바로위 파일로 이동 EX ( c:\JDK>cd .. = c:\> )

cd \ : 제일 위의 폴더위치로 이동 c:\JDK\FDA\FDFD\>cd \ = c:\

set : 수학의 집합 개념을 컴퓨터 과학에 도입한 것

path : 경로

javac : 자바소스를 번역

java : 자바 클래스를 실행

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

이클립스 (eclipse)

프로잭트 제목 대소문자 확인

글자 크기 조정 : Window - Preferences - 좌측 가장 위의 General - Editors - Text Editors - 상단 Colors and Fonts
 - Edit - 글자 크기조정 - 확인 - Apply

시작 : File - New - project - Java Project - JRE 3개중에 하나 체크 및 확인 - Module 체크해제 - finish

src 우클릭 - New - class - Package 도메인주소 {예시(com.sample)} - Name 작성 
- public static void main(String[] args ) 체크 - finish

새로운 패키지 생성 : 상위폴더 선택(src) - 우클릭 - new - 

코딩 단어(용어) ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- return 
-- 값을 반환한다
-- 함수를 끝낸다
-- 함수의 “출구” 역할

- this
--지금 사용 중인 객체 자기 자신
--객체 안에서 자기 자신의 변수나 함수를 가리키기 위해사용

- public
-- 어디서든 접근 가능하다라는뜻
-- 변수, 함수, 클래스 등을 외부에서도 접근할 수 있게 만들기 위해사용
-- 접근 범위를 조절해서 보안 + 구조 관리를 하기 위해사용

- private
-- 외부에서 접근 불가능, 내부에서만 사용 가능
-- 나만 쓸 수 있음 (클래스 내부 전용)
-- 중요한 데이터 보호
-- 실수로 값이 바뀌는 것 방지
-- 코드 구조를 깔끔하게 유지

- static
-- 객체를 만들지 않아도 사용할 수 있는 클래스 소속
-- 공용(클래스) 멤버
-- 모든 객체가 같이 사용하는 값/기능
-- 객체 생성 없이 바로 사용 가능
-- 메모리 절약

- new
-- 새 객체(인스턴스)를 만들라
-- 설계도(클래스)로부터 새 실체를 생성
-- 클래스 = 설계도 ,  new = 설계도로 실제 물건을 하나 만드는 것

- get
-- 값을 가져온다(조회한다)
-- 데이터 읽기용 메서드
-- private 변수 값을 안전하게 읽기 위해
-- 객체 내부 상태를 외부에 제공하기 위해

- set
-- 값을 설정한다 / 바꾼다
-- 데이터 수정용 메서드
-- private 변수 값을 안전하게 변경하기 위해
-- 값 변경 시 **검사(조건)**를 넣을 수 있음

                                   get / set 비교

    구분	              get	                    set

    역할	            값 읽기	                  값 변경

    반환값	  있음	                 보통 없음

    사용 목적	  조회	                    수정

- @Override 
-- 재정의 : 상위 클래스 매서드를 고쳐서 사용한다.
-- 실수 방지 (메서드 이름/매개변수 틀리면 오류)
-- 코드 가독성 ↑
-- 부모 메서드를 정확히 덮어썼는지 컴파일러가 확인

- length
-- 보통은 문자열이나 배열의 길이(length)를 구하는 방법을 묻는 경우가 많음
-- String s = "hello";
    s.length(); // 5

- Queue
-- 특징 : FIFO (First In, First Out)구조( 먼저 들어온 것이 먼저 나간다는 원칙 )
-- 이용 사례 : 프린터 출력 대기열, CPU 프로세스 스케줄링, BFS(너비 우선 탐색), 은행/콜센터 대기 시스템

- Map 
-- 코딩에서 Map 은 언어마다 이름과 사용법이 조금씩 다르지만 공통 개념은 Key–Value(키–값) 자료구조
-- Key는 중복 불가
-- Value는 중복 가능
-- 평균 탐색 속도: O(1)
-- 중복 횟수 세기, 빠른 검색, 값 매칭, 캐시 구현


단축키ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- main 컨트롤 스페이스, 첫번째 선택

- system.out.println("    "); = sysout + 컨트롤 + 스페이스 

- alt + ctrl + 방향키  = 횡복사(커서 위치 상관x)

- alt + 방향키 = 횡이동

- 컨트롤 + 스페이스 = 자동완성, 약어 찾기

- 상단 도구창 run = 코딩 결과확인

코드ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- System.out.print : 횡으로 이어서 작성 (자바에서 괄호 안의 내용을 콘솔(화면)에 출력하는 명령어이며, 
   println()과 달리 출력 후 줄바꿈을 하지 않습니다)

   코딩은 데이터 입력, 데이터 처리, 데이터 출력 순으로 진행됨

-- 예시: name = "홍길동";
           age = 25;
           System.out.print("이름:"+name);
           System.out.print("나이:"+age);
           이름:홍길동나이:25

           name = "박보검";
           age = 35;
           System.out.println("이름:"+name);
           System.out.println("나이:"+age);
           이름:박보검
           나이:35

- System.out.println : 자바(Java)에서 괄호 안의 내용(문자열, 숫자 등)을 콘솔(화면)에 출력하고, 
   자동으로 줄바꿈하는 명령어

-- 중간에  System.out.println() 집어넣으면 중간에 횡 넘길수있음(엔터 역할)

--- 예시: System.out.print("이름:"+name);
             System.out.print("나이:"+age);

             System.out.println();

             System.out.print("이름:"+name);
             System.out.print("나이:"+age);  
       
             이름:홍길동나이:25
             이름:박보검나이:35

-- System.out.printf : 자바에서 형식화된 문자열을 출력하는 메소드

--- 예시:  name = "홍길동";
            age = 20;
 
            System.out.printf("이름:%s 나이:%d",name,age);
            이름:홍길동 나이:20

--- 예시 2 : a=2 b=3 c=4

          System.out.printf("%2d, %2d, %2d,",a,b,c);

          2, 3, 4 가 나옴

변수ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

변수명 생성 규칙 

변수명은 영문자(대,소문자), 숫자, 밑줄(_), 달리 기호($)로만 구성 가능
변수명은 숫자로 시작할수없음
변수명에는 공백을 포함할수없음
자방서 미리 정의된 키워드를 변수명으로 사용할수없음

"123" 따로따로 일이삼 으로 읽음
""을 뺴고 123 은 백이십삼으로 읽음


주요 자료형의 종류 (책 68pg 그림 2-8 참조)

Alt 를 누른채로 숫자 입력시 "아스키 코드표"의 문자 입력가능

정수 자료형

System.out.println("--- 정수형 (Integer Types) 범위 ---");

예시 : System.out.println("byte: " + Byte.MIN_VALUE + " ~ " + Byte.MAX_VALUE);

byte : 가장 작은 정수형, 최솟값 -128, 최댓값이 127

short : 부호가있는 16비트 정수형, 최솟값은 -32,768, 최댓값은 32,767 

int : 가장 일반적으로 사용되는 부호가있는 32비트 정수형, 최솟값은 -2,147,483,648(2억) 최댓값은 2,147,483,647(2억)

* final int YEAR = 2025 이 YEAR 값을 2025에서 바꾸지 않음

long : 부호가있는 64비트 정수형, 최솟값은 -9,223,372,036,854,775,808 최댓값은 9,223,372,036,854,775,807{매우큰
정수(L또는 I접미사 사용)}

자세한 내용은 책 69~70 pg

자료형 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 실수 자료형
 
-- float : 실수라고도 하는 부동 소수점 숫자로, 이자율이나 제곱근계산과 같이 분수의 정밀도가 필요한 표현식에 사용

-- double : 64비트 부동 소수점 숫자로 sin(), cos(), sqrt()와같은 수학 계산에 사용

--- 자세한 내용은 책 71 pg

- 문자 자료형 

-- char : 문자와 숫자 등 문자 집합의 기호를 나타내는데 사용, 작은따옴표로 값을 묶어 표현하는데, 예를 들어'A'는 값이 65인 
    문자 상수입니다. 이는 단일 문자를 포함하는 문자열인 "A"와 다릅니다 ( '???' )

-- String : 문자열을 저장하는데 사용, String 자료형은 클래스에 해당하므로 반드시 대문자로 시작해야함 ( "???" )


불리언 자료형(boolean)ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

-불리언(Boolean) : 컴퓨터 과학, 프로그래밍, 논리학에서 참(True)과 거짓(False) 두 가지 값만 가지는 데이터 타입 또는 논리 개념

-- 예시
    boolean pass = true;
    char name = '\uae00';

    System.out.println("합격여부 :"+pass);
    System.out.println("name :"+name);

    합격여부 :true
    name :글

자세한 내용은 책 75 pg

이스케이프 문자 (특수문자)ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- \(역슬래시)

- \b - 백스페이스 - (유니코드값) \u0008

- \t - 탭 - \u0009

- \n - 줄바꿈(엔터) - \u000a

- \r - 캐리지 리턴 - \u000d

- \" - " (큰따옴표) - \u0022

- \' - ' (따옴표) - \u0027

- \\ - \ (역슬래시) - \u005c

연산자(operator)ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

-산술 연산자 : +(더하기), -(빼기), *(곱하기), /(나누기), %{왼쪽 피연산자를 오른쪽 피연산자로 나누고 나머지를 반환(중요한 기호)}

     * 정수끼리 나누면 정수로 밖에 나오지않음 (예시 - 10 / 3 = 3 (소수점 없음)) 실수(소수)를 나오게 하기위해서는 하나를 실수로 만들던가

-- {(  int a = 10;  ) , (  double b = 3.0;  ) (  System.out.println("a/b="+(a/b));  )}아니면 

    {(  int a = 10;  ) , (  int b = 3;  )(  System.out.println("a/b="+((double)(a)/b));  )} 와같은 계산식이 필요함

- 관계 연산자 : ==(같다), !=(같지않다), <,>(초과,미만) ,>=,<=(이상,이하)

- 논리 연산자  
--  &&{(두연산자의 조건이 모두 참이면 true 아니면 false를 반환) a && b (중요기호) }, 전기의 직렬연결을 생각하면 편함
     (ㅇ----//------//-----ㅇ) (하나의 버튼이라도 안켜지면 불이 안들어옴) 
                                                                                                                                                       
     ||{(두피연산자의 조건중 하나라도 참이면 true 아니면 false를 반환) a||b }, 전기의 병렬연결을 생각하면 편함 
     (ㅇ---------------//----------ㅇ)  (하나의 버튼이 안켜지더라도 불이 들어옴)                                                                                                                                                         
                 ㅣ_______//_______ㅣ

-- ! {(조건을 부정한다. 즉 피연산자의 조건이 참이면 false를 거짓이면 true를 반환) !a }

- 할당 연산자 : =,+=,-=,*=,/=,%=

- 증가 및 감소 연산자 : ++,--

--  ? : if의 약식(간단한 계산식은 처리가능하지만 복잡하면 if를 사용해야함)

       int max (num1 > num2)? num1 : num2

- 5 (피연산자)  + (연산자)   5 (피연산자)   =10

형변환 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 자동 형변환 : 작은 자료형을 큰 변수에 할당할때 더큰 자료형으로 변환함(예시 int형 변수에  short 값을 할당하는 경우)

-- byte > short > int > long > float > double  ( => 방형으로 변환)

- 캐스팅 형변환 : 작은 자료형의 변수에 더큰 자료형 값을 할당할 때는 명시적 유형 캐스팅을 수행

-- double > float > long > int > short > byte (=> 방향으로 변환)

입력처리 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- Scanner 클래스 : 키보드로 데이터를 입력을 받을 때 상용함

- Scanner 클래스 사용과정 

-- 1. Scanner 패키지 임포트 : import java.util.Scanner; 

-- 2. Scanner 객체 생성 : Scanner input = new Scanner(System.in); 

-- 3. 입력 메서드 호출 : String name = input.nextLine();

-- 문자 한자만 받는 스캐너 코드 : char ?? = kbd.next().charAt(0);

--- 예시 코드

      System.out.println();
      String name="";
      int age;

      Scanner kbd = new Scanner(System.in);
      System.out.print("이름 :");
      name = kbd.nextLine();

      System.out.print("나이 :");
      age = kbd.nextInt();

      System.out.println("이름 :"+name);
      System.out.println("나이 :"+(age-1));

      결과를보면 콘솔(결과창)에 이름과 나이를 입력할수있음

제어문 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 조건문 : 조건에 따라 처리하는 명령을 달리하는 문장 (if-else, switch)

- 반복문 : 일정하나 조건이 충족될때 까지 동일한 문장을 반복적으로 처리하는 문장(for , while, do-while)

- 분기문 : 강제로 명령의 처리 순서를 바꾸는 문장 (break, continue, return)

조건문 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- if 문 : 가장 간단한 조건문 (특정 코드또는 블록 실행 여부를 결정하는 데 사용)

- if~else 문 : if 문과 else문을 함께 사용하여 조건식의결과에 따라 특정 코드 또는 코드 블록의 실행을 선택하는 조건문

- if~else if 문 : if~else문과 유사하나 else문이 서로 다른 if문의 조건식과 쌍을 이루는 조건문, else if문의 수는 제한이 없고, else if문 코드 블록의 
  마지막에 else문의 코드 블록을 추가할수 있음

-- if 코드 예시

                         max = num1;
		if( num2 > max ) {
			max = num2;
		}else if(num3 > max ){
			max = num3;
		}

     위의 코드에서 num1 < num2 < num3 일경우 max(num1) 은 if( num2 > max ){ max = num1; } 에서 num2 의 수로 바뀌고
  
     if(num3 > max ){ max = num3; } 에서 num3 으로변함 3가지 수중에 가장 큰수를구할경우 위의 코드로 구할수있음

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- switch 문 : if~else if 문처럼 많은 선택 사항이 있고 각 선택 사항에 대해 특정 코드 또는 코드블록을 실행하는 조건문, 값과 실행코드를 적고 그다음
  값과 실행코드 사이에 break를 넣어 줘야됨

- case : switch 문에서 값에 해당됨

- break : 값과 값 사이를 나누는 코드

- default : 위에 제시된 예시 이외의값

- switch 문 예시는 133p 부터있음


반복문 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 반복문 : 일정 횟수만큼 어떤코드를 반복하여 실행하는 제어문
 
-- 운동을 예시로
    while - 목표를 달성할때까지 반복 ( 10kg이 빠질때까지 반복) 
    for - 목표 횟수 반복 (100 회 반복)

- while{(조건식) 문장;} : 주어진 조건이 만족되는 동안 문장들을 반복(조건이 참이면 반복되는 구조 거짓이 나오면 반복이 끝남)

-- 조건식-실행코드 (while 내부코드) 를 참인동안 반복하고 거짓이 되면 결과를 도출

--- 누적 sum 이 100이 넘을 때까지 i를 누적시킨다 ( i가 1 일때 sum 은 1이됨 i 가 2가되면 sum 은 앞의 1과 합쳐져 3이되는 식 )
      i=0;
      int sum=0;
      while(sum < 100) {
           sum=sum+i;
           System.out.println("합계 :"+sum);
           System.out.println("i :"+i);
           i++;     }


for문 : 특정 횟수만큼 실행해야 하는 루프를 효율적으로 사용용할수있는 반복문 138p 그림4-14

- 초기화식은 처음 한번만 실행 하고 "조건식 - 실행 코드 - 증감식" 을 반복

- for( 초기화식; 조건식; 증감식;) for(int i=0; i<10; i++)

- for문을 이용한 구구단 2단
   for(int i=1; i<=9; i++) {System.out.println(2+"x"+i+"="+(2*i));}

- do~while : while문과 for문처럼 조건식에 의해 반복 실행된다는 점은 비슷함, 하지만 조건식을 확인하기 전에 코드 블록의 코드가 한 번
   실행된다는 점이 다름

- do{ // 실행코드 } while (조건식);


배열 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 배열(array) : 동일한 타입의 변수들의 모임(배열은 변수를 모아놓은것, 배열은 하나의 이름을 공유한다.)

--  () =소괄호 {}=중괄호 []=대괄호

- 배열을 만드는 절차  

-- int[] myArr (배열 선언) = new int[5] (배열 생성)

- 배열의 크기를 구하는 법

-- int[] sungjuk = new int[10];
    int jumsu = 60;

    int ??? = sungjuk.length;

    위의 코드로 sungjuk 의 배열 크기를 .length 로 가져옴(.length 의 크기가 10 이된것 )

- 자주 사용되는 문자열 메서드 212p 표 6-1 (중요)

생성자

- 생성자의 특징

-- 생성자는 메소드

-- 생성자 이름은 클래스 이름과 동일해야한다

-- 생성자 여러개 작성 가능 (오버로딩)

-- 생성자는 abstract, final, static 을 선언할수없다.

-- 접근제한자는 생성자의 접근을 제어하는데 사용할수있다. 즉 다른 클래스가 생성자를 호출할수있다

- 객체가 생성될 때 초기화를 위해 실행되는 메소드 (기본객체 - 생성자 - 초기화된 객체)

- 문자들 끼리의 비교는 아래의 식과 같이 .equals(???) 이퀄 뒤의 괄호안에 넣고 비교해야함

-- String name1 = new String("Hello");
    String name3 = new String("Hello");
    if (name1.equals(name3)) {System.out.println("서로 같음");}else {
    System.out.println("서로 다르다");}


- class 내부 화면 우클릭 - sourse - generater getter and setter  

메서드ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

프로그램에서 특정 작업을 수행하기 위한 코드의 집합을 말함

[예]System.out.println() 메서드 : 콘솔세시지를 출력하는 기능의 함수 

1. 절차지향 프로그래밍 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

-함수기반



2.객체지향 프로그래밍ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 객체기반(부품조립)



- 실세계 객체의 특징 -

- 객체마다 고유한 특성(state)과 행동(behavior)을 가짐

- 다른 객체들과 정보를 주고 받는 등,상호작용하면서 존재


--- 컴퓨터 프로그램에서 객체 사례 ---

- 테트리스 게임의 각 블록들

- 한글 프로그램의 메뉴나 버튼들


- 캡슐화: 객체를 캡슐로 싸서 내부를 볼수없게 하는것 -

- 객체의 본절적인 특징

-- 외부의 접근으로부터 객체 보호

-- 자바의 캡슐화 --

- 클래스: 객체 모양을 선언한 틀

-- 메소드 와 필드 는 모드 클래스 내에 구현

- 객체 

-- 클래스의 모양대로 생성된 실체

-- 객체내 데이터에 대한 보호, 외부 접근 제한

--- 객체 외부에서는 비공개 맴버(필드, 매소드)에 직접 접근할수없음
 
--- 객채 외부에서는 공개된 메소드를 통해 비공개 맴버 접근

------ 클래스와 객체와의 관계 ---------

- 붕어빵 틀(클래스) 와 붕어빵(객체)와 같은 관계


접근제어 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

-  다른 클래스가 다른 특정한 필드나 메소드에 접근하는 것을 제어하는 것

추상화 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 추상화
-- 추상화란 불필요한 정보를 숨기고 중요한 정보만을 나타내는것을 의미
-- 추상화를 이용하면 어떤영역에서 필요한 공통의 속성이나 행동을 추출함으로써 효율적인 코드를 작성할수있다

- 추상화 사용의 장점
-- 객체 간의 복잡성이 줄어듦
-- 코드의 중복을 막고재사용성을 높일수 있음

- 추상클래스와 인터페이스의 비교
-- p340 표9-1참조

인터페이스 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 인터페이스 개념
-- 추상 클래스와 마찬가지로 인터페이스는 그 자체의 객체를 만들수없음
-- 추상 클래스는 추상 매서드와 일반 매서드를 포함할 수 있지만 인터페이스는 추상 매서드만 포함할수있음
-- 객체(부품)을 만드는 표준 규격을 정의하는 것
-- 메서드를 구현하지 않고, 메서드의 시그니쳐(메서드 이름, 매개변수, 반환값)만을 정의
-- 인터페이스는 다른 클래스에서 구현하여 사용하도록 함

- 인터페이스 사용 이유
-- 완전한 추상화를 구현할 수 있음
-- 다중 상속을 구현할 수 있음
-- 느슨한 결합 관계를 형성할 수 있음

-인터페이스의 특징
-- interface 키워드로 선언
-- 모든 메서드는 기본적으로 추상 메서드
-- 필드는 자동으로 public static final(상수)
-- 다중 구현 가능 → 클래스는 여러 인터페이스를 implements 할 수 있음
-- 객체 생성 불가 (추상클래스와 동일)

- 인터페이스를 사용하는 목적
-- “규칙”을 강제하기 위해
-- 서로 다른 클래스들을 같은 방식으로 다루기 위해
-- 다중 상속 문제를 해결하기 위해

예외처리 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

- 예외와 예외 처리

-- 예외
--- 프로그램의 정상적인 흐름을 방해하는 원치 않는 이벤트
--- 비정상 적인 예외가 발생하면 프로그램의 실행이 종료되고 시스템 생성 오류 메시지가 나타냄
--- 예 : 존재하지 않는 파일 열기, 네트워크 연결 실패, 잘못된 데이터 입력 등
      ( 이러한 문재를 처리할 수 있도록 예외를 발생시킴 )

-- 예외 처리
--- 애플리케이션의 정상적인 흐름을 유지할 수 있도록 런타임 오류를 처리하는 강력한 방법중 하나
--- 예 : 시스템 에서 생성된 오류 메시지

- 예외의 유형과 클래스

- 예외 클래스


컬렉션 ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

-컬렉션 프레임워크의 개념
-- 많은 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합을 말함
-- 데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 인터페이스
-- 컬렉션 프레임워크의 계층 구조 p527 표 13-2

- 컬렉션 프레임워크의 주요 인터페이스와 클래스

-- List<E> : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다
                 ArrayList, LinkedList, Vector

-- Set<E> : 순서가 없는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
                HashSet, TreeSet, LinkeedHashSet

-- Queue<E> : 요소가 헤드에서만 제거되는 특수한 종류의 목록을 처리하도록 컬렉션을 확장한다.
                    ArrayDeque, PriorityQueue

-- Map<K,V> : 순서가 없는 키와 값 한 쌍으로 이루어진 데이터의 집합으로, 키는 중복될 수 없지만 값은 중복될수있다.
                   HashMap, TreeMap, HashTable, LinkedHashMap

- 컬렉션 프레임워크의 주요 공통 메서드 p528 표13-3 

- List 컬렉션












 











